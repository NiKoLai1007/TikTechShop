{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport React from 'react';\nimport classNames from 'classnames';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n    handle = _ref.handle,\n    bounds = _ref.bounds,\n    props = _ref.props;\n  var allowCross = props.allowCross,\n    pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\nvar Range = /*#__PURE__*/function (_React$Component) {\n  _inherits(Range, _React$Component);\n  var _super = _createSuper(Range);\n  function Range(props) {\n    var _this;\n    _classCallCheck(this, Range);\n    _this = _super.call(this, props);\n    _this.positionGetValue = function (position) {\n      var bounds = _this.getValue();\n      var value = _this.calcValueByPos(position);\n      var closestBound = _this.getClosestBound(value);\n      var index = _this.getBoundNeedMoving(value, closestBound);\n      var prevValue = bounds[index];\n      if (value === prevValue) return null;\n      var nextBounds = _toConsumableArray(bounds);\n      nextBounds[index] = value;\n      return nextBounds;\n    };\n    _this.onEnd = function (force) {\n      var handle = _this.state.handle;\n      _this.removeDocumentEvents();\n      if (!handle) {\n        _this.dragTrack = false;\n      }\n      if (handle !== null || force) {\n        _this.props.onAfterChange(_this.getValue());\n      }\n      _this.setState({\n        handle: null\n      });\n    };\n    var count = props.count,\n      min = props.min,\n      max = props.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n    var value = props.value !== undefined ? props.value : defaultValue;\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: bounds\n    };\n    return _this;\n  }\n  /**\n   * [Legacy] Used for inherit other component.\n   * It's a bad code style which should be refactor.\n   */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars, class-methods-use-this */\n\n  _createClass(Range, [{\n    key: \"calcValueByPos\",\n    value: function calcValueByPos(value) {\n      return 0;\n    }\n  }, {\n    key: \"getSliderLength\",\n    value: function getSliderLength() {\n      return 0;\n    }\n  }, {\n    key: \"calcOffset\",\n    value: function calcOffset(value) {\n      return 0;\n    }\n  }, {\n    key: \"saveHandle\",\n    value: function saveHandle(index, h) {}\n  }, {\n    key: \"removeDocumentEvents\",\n    value: function removeDocumentEvents() {}\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n      var _this$props = this.props,\n        onChange = _this$props.onChange,\n        value = _this$props.value,\n        min = _this$props.min,\n        max = _this$props.max;\n      if (!('min' in this.props || 'max' in this.props)) {\n        return;\n      }\n      if (min === prevProps.min && max === prevProps.max) {\n        return;\n      }\n      var currentValue = value || prevState.bounds;\n      if (currentValue.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.props);\n      })) {\n        var newValues = currentValue.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.props);\n        });\n        onChange(newValues);\n      }\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['handle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n      var data = _objectSpread(_objectSpread({}, this.state), state);\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart(position) {\n      var props = this.props,\n        state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n      var nextBounds = _toConsumableArray(state.bounds);\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    }\n  }, {\n    key: \"onMove\",\n    value: function onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      var state = this.state,\n        props = this.props;\n      var maxValue = props.max || 100;\n      var minValue = props.min || 0;\n      if (dragTrack) {\n        var pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        var max = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));\n        var min = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));\n        var ratio = Math.min(Math.max(pos / (this.getSliderLength() / (maxValue - minValue)), min), max);\n        var nextBounds = startBounds.map(function (v) {\n          return Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue));\n        });\n        if (state.bounds.map(function (c, i) {\n          return c === nextBounds[i];\n        }).some(function (c) {\n          return !c;\n        })) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n        return;\n      }\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    }\n  }, {\n    key: \"onKeyboard\",\n    value: function onKeyboard(e) {\n      var _this$props2 = this.props,\n        reverse = _this$props2.reverse,\n        vertical = _this$props2.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n          props = this.props;\n        var bounds = state.bounds,\n          handle = state.handle;\n        var oldValue = bounds[handle === null ? state.recent : handle];\n        var mutatedValue = valueMutator(oldValue, props);\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: handle,\n          bounds: state.bounds,\n          props: props\n        });\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: \"getClosestBound\",\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n      var closestBound = 0;\n      for (var i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n      return closestBound;\n    }\n  }, {\n    key: \"getBoundNeedMoving\",\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _this$state = this.state,\n        bounds = _this$state.bounds,\n        recent = _this$state.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n      return boundNeedMoving;\n    }\n  }, {\n    key: \"getLowerBound\",\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: \"getUpperBound\",\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n      return bounds[bounds.length - 1];\n    }\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      var _this$props3 = this.props,\n        marks = _this$props3.marks,\n        step = _this$props3.step,\n        min = _this$props3.min,\n        max = _this$props3.max;\n      var cache = this.internalPointsCache;\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _objectSpread({}, marks);\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this.internalPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n      return this.internalPointsCache.points;\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n      var state = this.state,\n        props = this.props;\n      var nextBounds = _toConsumableArray(state.bounds);\n      var handle = state.handle === null ? state.recent : state.handle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n      this.onChange({\n        recent: nextHandle,\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.props.onAfterChange(nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    }\n  }, {\n    key: \"pushSurroundingHandles\",\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var direction = 0;\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        // eslint-disable-next-line no-param-reassign\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: \"pushHandle\",\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          // eslint-disable-next-line no-param-reassign\n          bounds[handle] = originalValue;\n          return false;\n        }\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n      return true;\n    }\n  }, {\n    key: \"pushHandleOnePoint\",\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n      // eslint-disable-next-line no-param-reassign\n\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: \"trimAlignValue\",\n    value: function trimAlignValue(value) {\n      var _this$state2 = this.state,\n        handle = _this$state2.handle,\n        bounds = _this$state2.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: handle,\n        bounds: bounds,\n        props: this.props\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n      var _this$state3 = this.state,\n        handle = _this$state3.handle,\n        bounds = _this$state3.bounds;\n      var _this$props4 = this.props,\n        prefixCls = _this$props4.prefixCls,\n        vertical = _this$props4.vertical,\n        included = _this$props4.included,\n        disabled = _this$props4.disabled,\n        min = _this$props4.min,\n        max = _this$props4.max,\n        reverse = _this$props4.reverse,\n        handleGenerator = _this$props4.handle,\n        trackStyle = _this$props4.trackStyle,\n        handleStyle = _this$props4.handleStyle,\n        tabIndex = _this$props4.tabIndex,\n        ariaLabelGroupForHandles = _this$props4.ariaLabelGroupForHandles,\n        ariaLabelledByGroupForHandles = _this$props4.ariaLabelledByGroupForHandles,\n        ariaValueTextFormatterGroupForHandles = _this$props4.ariaValueTextFormatterGroupForHandles;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n        var mergedTabIndex = tabIndex[i] || 0;\n        if (disabled || tabIndex[i] === null) {\n          mergedTabIndex = null;\n        }\n        var dragging = handle === i;\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          dragging: dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabIndex: mergedTabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames2));\n        return /*#__PURE__*/React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          reverse: reverse,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n      return {\n        tracks: tracks,\n        handles: handles\n      };\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      if (!('value' in props || 'min' in props || 'max' in props)) {\n        return null;\n      }\n      var value = props.value || state.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: state.bounds,\n          props: props\n        });\n      });\n      if (state.bounds.length === nextBounds.length) {\n        if (nextBounds.every(function (v, i) {\n          return v === state.bounds[i];\n        })) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            props: props\n          });\n        });\n      }\n      return _objectSpread(_objectSpread({}, state), {}, {\n        bounds: nextBounds\n      });\n    }\n  }]);\n  return Range;\n}(React.Component);\n/* eslint-enable */\n\nRange.displayName = 'Range';\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  draggableTrack: false,\n  tabIndex: [],\n  ariaLabelGroupForHandles: [],\n  ariaLabelledByGroupForHandles: [],\n  ariaValueTextFormatterGroupForHandles: []\n};\nexport default createSlider(Range);","map":{"version":3,"names":["_defineProperty","_objectSpread","_toConsumableArray","_classCallCheck","_createClass","_inherits","_createSuper","React","classNames","Track","createSlider","utils","_trimAlignValue","trimAlignValue","_ref","value","handle","bounds","props","allowCross","pushable","thershold","Number","valInRange","ensureValueInRange","valNotConflict","undefined","length","ensureValuePrecision","Range","_React$Component","_super","_this","call","positionGetValue","position","getValue","calcValueByPos","closestBound","getClosestBound","index","getBoundNeedMoving","prevValue","nextBounds","onEnd","force","state","removeDocumentEvents","dragTrack","onAfterChange","setState","count","min","max","initialValue","Array","apply","map","defaultValue","v","i","recent","key","getSliderLength","calcOffset","saveHandle","h","componentDidUpdate","prevProps","prevState","_this2","_this$props","onChange","currentValue","some","isValueOutOfRange","newValues","isNotControlled","controlledState","forEach","item","Object","keys","data","changedValue","onStart","onBeforeChange","startValue","startPosition","prevMovedHandleIndex","onMove","e","startBounds","pauseEvent","maxValue","minValue","pos","vertical","reverse","Math","ratio","floor","c","oldValue","moveTo","onKeyboard","_this$props2","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","abs","_this$state","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","_this$props3","marks","step","cache","internalPointsCache","pointsObject","point","points","parseFloat","sort","a","b","_this3","nextHandle","pushSurroundingHandles","indexOf","handlesRefs","focus","threshold","direction","diffToNext","pushHandle","amount","originalValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","_this$state2","render","_this4","_this$state3","_this$props4","prefixCls","included","disabled","handleGenerator","trackStyle","handleStyle","tabIndex","ariaLabelGroupForHandles","ariaLabelledByGroupForHandles","ariaValueTextFormatterGroupForHandles","offsets","handleClassName","concat","handles","_classNames","mergedTabIndex","dragging","className","offset","style","ref","ariaLabel","ariaLabelledBy","ariaValueTextFormatter","tracks","slice","_","_classNames2","trackClassName","createElement","getDerivedStateFromProps","every","Component","displayName","defaultProps","draggableTrack"],"sources":["C:/Users/Admin/TikTechShop/frontend/node_modules/rc-slider/es/Range.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport React from 'react';\nimport classNames from 'classnames';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar Range = /*#__PURE__*/function (_React$Component) {\n  _inherits(Range, _React$Component);\n\n  var _super = _createSuper(Range);\n\n  function Range(props) {\n    var _this;\n\n    _classCallCheck(this, Range);\n\n    _this = _super.call(this, props);\n\n    _this.positionGetValue = function (position) {\n      var bounds = _this.getValue();\n\n      var value = _this.calcValueByPos(position);\n\n      var closestBound = _this.getClosestBound(value);\n\n      var index = _this.getBoundNeedMoving(value, closestBound);\n\n      var prevValue = bounds[index];\n      if (value === prevValue) return null;\n\n      var nextBounds = _toConsumableArray(bounds);\n\n      nextBounds[index] = value;\n      return nextBounds;\n    };\n\n    _this.onEnd = function (force) {\n      var handle = _this.state.handle;\n\n      _this.removeDocumentEvents();\n\n      if (!handle) {\n        _this.dragTrack = false;\n      }\n\n      if (handle !== null || force) {\n        _this.props.onAfterChange(_this.getValue());\n      }\n\n      _this.setState({\n        handle: null\n      });\n    };\n\n    var count = props.count,\n        min = props.min,\n        max = props.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n    var value = props.value !== undefined ? props.value : defaultValue;\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: bounds\n    };\n    return _this;\n  }\n  /**\n   * [Legacy] Used for inherit other component.\n   * It's a bad code style which should be refactor.\n   */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars, class-methods-use-this */\n\n\n  _createClass(Range, [{\n    key: \"calcValueByPos\",\n    value: function calcValueByPos(value) {\n      return 0;\n    }\n  }, {\n    key: \"getSliderLength\",\n    value: function getSliderLength() {\n      return 0;\n    }\n  }, {\n    key: \"calcOffset\",\n    value: function calcOffset(value) {\n      return 0;\n    }\n  }, {\n    key: \"saveHandle\",\n    value: function saveHandle(index, h) {}\n  }, {\n    key: \"removeDocumentEvents\",\n    value: function removeDocumentEvents() {}\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          onChange = _this$props.onChange,\n          value = _this$props.value,\n          min = _this$props.min,\n          max = _this$props.max;\n\n      if (!('min' in this.props || 'max' in this.props)) {\n        return;\n      }\n\n      if (min === prevProps.min && max === prevProps.max) {\n        return;\n      }\n\n      var currentValue = value || prevState.bounds;\n\n      if (currentValue.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.props);\n      })) {\n        var newValues = currentValue.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.props);\n        });\n        onChange(newValues);\n      }\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['handle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _objectSpread(_objectSpread({}, this.state), state);\n\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart(position) {\n      var props = this.props,\n          state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = _toConsumableArray(state.bounds);\n\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    }\n  }, {\n    key: \"onMove\",\n    value: function onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      var state = this.state,\n          props = this.props;\n      var maxValue = props.max || 100;\n      var minValue = props.min || 0;\n\n      if (dragTrack) {\n        var pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        var max = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));\n        var min = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));\n        var ratio = Math.min(Math.max(pos / (this.getSliderLength() / (maxValue - minValue)), min), max);\n        var nextBounds = startBounds.map(function (v) {\n          return Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue));\n        });\n\n        if (state.bounds.map(function (c, i) {\n          return c === nextBounds[i];\n        }).some(function (c) {\n          return !c;\n        })) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n\n        return;\n      }\n\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    }\n  }, {\n    key: \"onKeyboard\",\n    value: function onKeyboard(e) {\n      var _this$props2 = this.props,\n          reverse = _this$props2.reverse,\n          vertical = _this$props2.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n            props = this.props;\n        var bounds = state.bounds,\n            handle = state.handle;\n        var oldValue = bounds[handle === null ? state.recent : handle];\n        var mutatedValue = valueMutator(oldValue, props);\n\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: handle,\n          bounds: state.bounds,\n          props: props\n        });\n\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: \"getClosestBound\",\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    }\n  }, {\n    key: \"getBoundNeedMoving\",\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _this$state = this.state,\n          bounds = _this$state.bounds,\n          recent = _this$state.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    }\n  }, {\n    key: \"getLowerBound\",\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: \"getUpperBound\",\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n      return bounds[bounds.length - 1];\n    }\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      var _this$props3 = this.props,\n          marks = _this$props3.marks,\n          step = _this$props3.step,\n          min = _this$props3.min,\n          max = _this$props3.max;\n      var cache = this.internalPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _objectSpread({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this.internalPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this.internalPointsCache.points;\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var state = this.state,\n          props = this.props;\n\n      var nextBounds = _toConsumableArray(state.bounds);\n\n      var handle = state.handle === null ? state.recent : state.handle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.props.onAfterChange(nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    }\n  }, {\n    key: \"pushSurroundingHandles\",\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        // eslint-disable-next-line no-param-reassign\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: \"pushHandle\",\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          // eslint-disable-next-line no-param-reassign\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    }\n  }, {\n    key: \"pushHandleOnePoint\",\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n      // eslint-disable-next-line no-param-reassign\n\n\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: \"trimAlignValue\",\n    value: function trimAlignValue(value) {\n      var _this$state2 = this.state,\n          handle = _this$state2.handle,\n          bounds = _this$state2.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: handle,\n        bounds: bounds,\n        props: this.props\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var _this$state3 = this.state,\n          handle = _this$state3.handle,\n          bounds = _this$state3.bounds;\n      var _this$props4 = this.props,\n          prefixCls = _this$props4.prefixCls,\n          vertical = _this$props4.vertical,\n          included = _this$props4.included,\n          disabled = _this$props4.disabled,\n          min = _this$props4.min,\n          max = _this$props4.max,\n          reverse = _this$props4.reverse,\n          handleGenerator = _this$props4.handle,\n          trackStyle = _this$props4.trackStyle,\n          handleStyle = _this$props4.handleStyle,\n          tabIndex = _this$props4.tabIndex,\n          ariaLabelGroupForHandles = _this$props4.ariaLabelGroupForHandles,\n          ariaLabelledByGroupForHandles = _this$props4.ariaLabelledByGroupForHandles,\n          ariaValueTextFormatterGroupForHandles = _this$props4.ariaValueTextFormatterGroupForHandles;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n\n        var mergedTabIndex = tabIndex[i] || 0;\n\n        if (disabled || tabIndex[i] === null) {\n          mergedTabIndex = null;\n        }\n\n        var dragging = handle === i;\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          dragging: dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabIndex: mergedTabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames2));\n        return /*#__PURE__*/React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          reverse: reverse,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n      return {\n        tracks: tracks,\n        handles: handles\n      };\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      if (!('value' in props || 'min' in props || 'max' in props)) {\n        return null;\n      }\n\n      var value = props.value || state.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: state.bounds,\n          props: props\n        });\n      });\n\n      if (state.bounds.length === nextBounds.length) {\n        if (nextBounds.every(function (v, i) {\n          return v === state.bounds[i];\n        })) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            props: props\n          });\n        });\n      }\n\n      return _objectSpread(_objectSpread({}, state), {}, {\n        bounds: nextBounds\n      });\n    }\n  }]);\n\n  return Range;\n}(React.Component);\n/* eslint-enable */\n\n\nRange.displayName = 'Range';\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  draggableTrack: false,\n  tabIndex: [],\n  ariaLabelGroupForHandles: [],\n  ariaLabelledByGroupForHandles: [],\n  ariaValueTextFormatterGroupForHandles: []\n};\nexport default createSlider(Range);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}